抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。  
![[Pasted image 20240715182555.png]]

## 适用场景

- 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。
- 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。
- 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。

## 实现方式

让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。  
在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。  
![[Pasted image 20240715182627.png]]  
![[Pasted image 20240715182659.png]]

## 优点

 你可以避免创建者和具体产品之间的紧密耦合。  
 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。  
 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

 ## 缺点

  应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。

  ## 与其他模式的关系

在许多设计工作的初期都会使用[[工厂方法模式]] （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[[抽象工厂模式]]、 [[原型模式]]或[[生成器模式]] （更灵活但更加复杂）。

生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。

[[抽象工厂模式]]通常基于一组`工厂方法`， 但你也可以使用`原型模式`来生成这些类的方法。

当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替[[外观模式]]。

你可以将抽象工厂和[[桥接模式]]搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。

抽象工厂、 生成器和原型都可以用[[单例模式]]来实现。
